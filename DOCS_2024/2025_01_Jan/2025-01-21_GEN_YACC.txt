	2025-01-21
	2025-01-21_GEN_YACC.txt

	$HOME/YEAR/src/PREP/PSG_SCRIPT/GEN_YACC_eg/GEN_YACC_bison_info
	$HOME/YEAR/src/PREP/

		PREP is a BUNDLE of PROJECTS
		UNRELATED and COMBINATIONS

	PSG_SCRIPT/

		PSG_SCRIPT will be a bundle of features with DIALECT etc
		It parses ASCII, and might accept utf8, as it is 8 bit clean
		CSET_UTF8
		CSET_BYTE
		CSET_ASCII
		CSET_Latin1
		CSET_Cryillic
		CSET_UNICODE
		CSET_PRINTER
		
		Phrase { SEQ ... }
		Phrase { sequenced list of steps in SCRIPT when TOKENISED }
		Phrase { HERE = TREE_ALLOC REQ }
		// Turns out
		// REQ causes a predictable block in non-blocking-call

		PSG += Phrase
		PSG += LISTS_in_source // bind var
		PSG += TOKEN_POOLS // and SUB_LEX features
		PSG += Module_provides_starter lists and VAR_POOLS
		PSG += Module_FFFF_VAR_POOL_FF

			our feature is going to get agregated
			ie become one idx_ITEM in a heap of many

			all our uses are bundled into Module_FFFF
			which is probably a TREE_POS_HEAP_ITEM_ADDR_IDX

			we also use AUTO_GROW so after u15 comes u31 u63
			we also use BITFIELD_u12_u4
			we also use BITFIELD_u4_u12

UNIX:
	When your write TREE_DATA_EDITS

		GRAFT NEW DECL ITEM_DATA ITEM_SCRIPT MODULE_FEATURES

		ORDER LIST_one LIST_two 
		ORDER
		 LIST_one 1 2 3
		 LIST_two 1 3 2
		 DIFF_try_swap_pair_signle_few_


	 GEN_YACC_eg/

	 	This is an example of a ARGV parser mostly like Tcl 

		SP1 -vs- GAP 
		GAP += NOGAP eg because ([mid]) PUNCT can read this and_HALF
		PUNCT // WORD_comma // LEFT SP1 WORD SP1 RIGHT //
		// LEFT "{" // "}"
		// RIGHT "}" // PAIR "{" "}" // BRACES $1 $2 // BRACES LEFT RIGHT //

		CT_RT looks at it and allows EA of any UDEF
		CT_RT looks at it and runs test data with hacked_in_extra
		CT_RT looks at it and MATCH VAR_NAME_EXPR
		YES KNOW it is a AVAR because Module makes it automatic

		HEAP_ITEM_EXPR_WRITE_FIELD OPCODE DATA

		"{ ([expr]) }"
		expr looks like an int_idx
		[IDX] is array[N] or EIGHT_t or FOUR_t or PAIR_t or BYTE_t
		[IDX] is array[N] or EIGHT   or FOUR   or PAIR   or BYTE  

	This is an example of a generic c++ parser // in primative form
	This is an example of a generic SCRIPT parser // cxx in ARGV form
	// slightly verbose, but multi_step_PUNCT uses some magic
	//  ([expr]) // function that acts like an array and helps with expr
	//  ([idx]) // function that acts like an array and idx from ALLOC
	// ALLOC idx = N ++ // but not now, some long time ago, STREAM_DATA
	// ALLOC AUTO GROW u7 u15 u31 u63 // 
	// HALF_one HALF_HALF //
	// HALF_two HIGH_HALF //
	// STOP_at_u31 // which actually means STOP_at_u32 // ALIAS i32 u32
	// I stop at u31 because that is plenty for me // LIMIT
	// I add u11 u23 and a generic NBITS SIGNED never_empty_N

		CXX code is used to GEN a PSG and a SUB_LEX

		we are attempting to live within a SUBSET
		it's as close to simple c++ as we can be bothered, but not more
		we can get confused with >> looking like >_>

		AVAR += DAFT EXPR

		Everything there is performative
		which is too much to spell for cxx
		but decodes well in DIAG

		SCRIPT += if += while += DECL 
		SCRIPT += PSG_SCRIPT_FEATURES
		PSG += SCRIPT

	  GEN_YACC_bison_info/

	/../../PLAY/PSG_SCRIPT/GEN_YACC/Tuplo/src/lib_YY_parse/YY_PARSE_gen.cxx



