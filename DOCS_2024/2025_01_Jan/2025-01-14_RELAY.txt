	2025-01-14
	2025-01-14_RELAY.txt

	MESSAGE RELAY

	One idea is to track every single message thread, and tree of them,
	the other is simply let them loose and give them good maps.

	ENQ_ACK_ID

	When ENQ is formulated it gets an ID
	When ACK is received it gets an ID - ignored
	When ACK is decoded it uses ENQ.ID and ACK.ID
	When ENQ cascades to other ENQ it allocs IDX2
	When chain is > 2 switch to PTR to OBJ within TREE 

	SWEEP_GROUPS_OF_ACKS

		process everything that CPU can do
		GEN all output buffers
		SYNC STEP ALL output buffers

			this adds a bit to the buffers
			it marks the end of the ERA LIST
			some things have not reported back 
			and straddle this edge and mmaybe others
			
			SYNC edge must do some of this
			
			everything is queued to be sent, NEXT STEP
			mark HERE in sequence implies all up to date upto here

			does not need to be XMIT'd yet,
			but we PUSH_SOON which queues the DATA for SEND SOON
			our QUOTA give us a nice priority,
			because we BATCH up 1 minute of 10% to 6 seconds
			that saves a lot in CPU switching
			it gains a lot in CPU CACHE

			it gains more when SCHEDULER keeps finding 6 seconds
			SCHEDULER can also send a MINI_SYNC_PAUSE
			that completes each EOLN, optionally wait for RETURN
			optionally suspend mid-action

			running upto eoln saves REJOIN 
			running upto eoln gains not much

		SYNC RELAY

			CODE promises to leave whatevr is found at NEXT_SYNC
			LAST_SYNC
			NEXT_SYNC
			ZONE_NAME era of PREV_SYNC_DONE
			ZONE_NAME era to NEXT_SYNC_DONE
	
	SWEEP for all ENQ_ACK left waiting

		shutdown ERA when ALL DONE or PENDING
		retransmit buffers are associated with these buffers
		so we use them for that, and help them complete

	SWEEP_COMMS

		SYNC_CLICK heartbeat

			on_SWEEP_for_DONE
			on_STEP_through_for_loop sync

		send SYNC_EXACTLY # APPS says wants it HERE #

			# SYNC_EDGE # NEW_ZONE_ID # is AVAR("NEW_ZONE_ID")

		send SYNC_EARLY # in case of flush early
		tell queues to get a wiggle on
		wait for other things that can be done within this CPU cycle
		do be careful here - inside is CUT_CPU at next WORD
		outside is now:
			serialise pack and send
			convert ITEM QUEUE to BYTES queue on FD
			sweep all lists to get empty QUEUE SWEEP

				PERMIT SYNC EDGE PREV_CURR_NEXT 

					many tasks take several cycles
					entire batch might even have a roll_BACK
					GROUP_PAGE_COMMIT here and there

					when TASK completes,
					its report sent REMOTE to LOCAL
					told as part of later packet
					but given an actual ID - or now

			HALT_SWEEP_MOMENT

				this must never block for 1 second 0.01
				everything must halt
				the requested list must be clear in the sweep
				the SWEEP can have its own OPINION
				any other already available SPEEPS ?
				everything may restart
y}
				on_SWEEP_for_DONE
				on_STEP_through_for_loop sync

			WITH BATCH

				entire run take micro second, all in 1
				obtaining locks and informing of change TODO





	BOTH can use ref_counting via clever mechanisms, or GC, or 

		RESEND in case of LOST_PACKET
		  SEND in case of COPY_REQUEST
		 ALLOC in HEAP as i12_idx // USES i16 as i8_i8 as i4_i8
	
	LOCAL REMOTE

		BOTH PAIR_BOND to some extent
		SIMUL RULES - tell when SYNC edge arrived - PENDING UPDATE
		// nb no PREV value is available just CURR as NEXT
		// or MMAP PREV_CURR_NEXT

		LOCAL CACHE
		+= also holds please_notify_me_on_change_subscription
		+= on_CHANGE EVENT
		+= subscribe to notifications from REMTE

		LOCAL is this ITEM and everything generally LOCAL
		REMOTE is that ITEM and everything generally REMOTE

		COMMON SERVICE RULES
		SUBSCRIPTION to LOCK 
		+= DELAYED_COMMS_and_ONGOING_SIDE_CHANGES
		send BATCH
		process lines until 1 second has passed



